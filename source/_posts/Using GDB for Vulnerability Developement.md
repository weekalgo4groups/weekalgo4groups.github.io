---
title: Using GDB for Vulnerability Developement 
date: 2017-02-05 23:21:37
categories: pwn
---

#使用gdb进行漏洞挖掘
> - by hook

-------
## 1. layout的分割窗口
ayout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：
layout src：显示源代码窗口
layout asm：显示汇编窗口
layout regs：显示源代码/汇编和寄存器窗口
layout split：显示源代码和汇编窗口
layout next：显示下一个layout
layout prev：显示上一个layout
Ctrl + L：刷新窗口
Ctrl + x，再按1：单窗口模式，显示一个窗口
Ctrl + x，再按2：双窗口模式，显示两个窗口
Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。
## 2. hacker插件
### <1>. peda
PEDA - Python Exploit Development Assistance for GDB(https://github.com/longld/peda)
可以很清晰的查看到堆栈信息，寄存器和反汇编信息
![](/images/Using GDB for Vulnerability Developement/1.jpg)

还有checksec, vmmap等等功能, 并且能够很方便的寻找用于ROP攻击的Gadget指令。

### <2>. GEF
GDB Enhanced Features(https://github.com/hugsy/gef)
可以说是peda的增强版，因为它支持更多的架构(ARM, MIPS, POWERPC...)，和更加强大的模块,并且和ida联动。
![](/images/Using GDB for Vulnerability Developement/2.jpg)
可以动态生成指定架构的shellcode
![](/images/Using GDB for Vulnerability Developement/3.jpg)
查看堆内存信息
![](/images/Using GDB for Vulnerability Developement/4.jpg)

### <3>.libheap(查看堆信息)
(https://github.com/cloudburst/libheap)
(gdb) python from libheap import *
(gdb) heap -h
==================== Heap Dump=========================
Options:
  -a 0x1234 指定arena地址
  -b        输出压缩的bin列表(只是空闲数据块)
  -c        输出压缩的arena列表(所有数据块)
  -f [#]    输出所有的fast bin，或独立的fast bin
  -l        输出arena 中所有数据块的flat列表
  -s [#]    输出所有的small bin，或独立的small bin
  
(gdb) heap -f
==================== HeapDump=========================
[ fb  0 ] 0xf2f3a8 -> [0x0804b000 ] (16)

[ fb  1 ] 0xf2f3ac -> [0x00000000 ]

[ fb  2 ] 0xf2f3b0 -> [0x00000000 ]

[ fb  3 ] 0xf2f3b4 -> [0x00000000 ]

[ fb  4 ] 0xf2f3b8 -> [0x00000000 ]

[ fb  5 ] 0xf2f3bc -> [0x00000000 ]

[ fb  6 ] 0xf2f3c0 -> [0x00000000 ]

[ fb  7 ] 0xf2f3c4 -> [0x00000000 ]

[ fb  8 ] 0xf2f3c8 -> [0x00000000 ]

[ fb  9 ] 0xf2f3cc -> [0x00000000 ]
## 3.调试堆等其他内核信息时的技巧
### 1.glibc符号
在使用上述工具调试堆信息时，发现gdb并不能打印main_arena信息，原因在于linux为了系统安全，将release版glibc中的符号裁剪掉了，所以第一件事先来恢复符号表。
```
apt-get install libc6-dbg
```
这样将会下载debug版的glibc放在/usr/lib/debug/目录下
编译程序时使用
```
gcc -g main.c -o main -Wl,-rpath=/usr/lib/debug/
```
gdb调试时发现
```
(gdb) set verbose on
(gdb) run
Starting program: /opt/a.out 
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/ld-2.23.so...done.
done.
Reading symbols from system-supplied DSO at 0x7ffff7ffa000...(no debugging symbols found)...done.
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.23.so...done.
```
在载入libc.so.6等glibc库时，成功从debug目录载入了符号表,再用gdb去调试跟踪malloc等函数时，会发现可以顺利进入glibc的代码跟踪下去。
### 2.glibc源码的查看
像自己编写的程序因为有源代码，所以gcc -g后在gdb中list是能看到源码信息的，但是，如果想一路跟踪到glibc中，并且实时查看代码的话就必须要获取glibc源码了。
```
apt-get source libc6-dev
```
这样在调试时，gdb指定目录后就可以看到信息
```
(gdb) directory /usr/src/glibc-2.23/malloc/
```
![](/images/Using GDB for Vulnerability Developement/5.jpg)

![](/images/Using GDB for Vulnerability Developement/6.jpg)

![](/images/Using GDB for Vulnerability Developement/7.jpg)





